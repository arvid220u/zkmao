{"version":3,"sources":["p2p.js","assert.js","utils.js","cards.js","config.js","rules.js","logic.js","Chat.js","Game.js","App.js","reportWebVitals.js","index.js"],"names":["RTC_CONFIG","iceServers","urls","onOpen","conn","console","log","messageHandlers","data","type","value","indx","onMessage","e","JSON","parse","addMessageHandler","handler","messageHandlersIndx","parseInt","removeMessageHandler","key","send","json","dc","stringify","encodeKey","btoa","replace","decodeKey","str","length","slice","atob","assert","condition","error_m","error","shuffle","array","rng","temporaryValue","randomIndex","currentIndex","Math","floor","unimplemented","hash","message","a","encoder","TextEncoder","encode","crypto","subtle","digest","hashBuffer","hashArray","Array","from","Uint8Array","hashHex","map","b","toString","padStart","join","RANK","RANKS","SUITS","VOID_CARD","shuffledDeck","startFromRankIndex","utils","deck","suit_index","index","suit","rank_index","rank","push","orderedDeck","serializeCard","card","firstChar","charCodeAt","secondChar","String","fromCharCode","serializeCardASCII","charAt","toUpperCase","serializeDeck","deckstr","sameCard","c1","c2","EVERYONE","createPrivateRule","name","source","owner","rule","compiled","compileSource","hashCompiledSource","publicRule","sameRule","r1","r2","determinePenalties","playedCards","selectedRules","myRules","proof","penalty","PHASE","SETUP","PLAY","GAMEOVER","ABORT","PHASES","Object","values","SETUP_STATE","PRE_READY","SENT_READY","SENT_START","PLAY_STATE","WAIT_FOR_PLAY","WAIT_FOR_PLAYACK","METHOD","READY","START","PLAYACK","METHODS","METHOD_HANDLER","game","m","phase","abort","state","user","players","includes","readyHashes","maybeSendStart","update","rules","nextTurn","cards","playerHands","some","c","legalToPlayCard","actuallyPlayCard","provedRules","method","acksReceived","userId","maybeStopWaitingForAcks","sendPlayAck","lastPlayedUser","lastPlayedCard","createGame","listeners","listenerIndex","random","substr","allRules","initPhase","then","setUpPublicRules","resetPhase","args","startNumbers","myRandom","sort","users","addListener","listener","removeListener","randomNumber","keys","randomNumberHash","maybeStartGame","reason","filter","lastCard","playCard","isMyTurn","every","x","sendReady","hash_r","l","winner","checkIfWon","finalRandomNumber","forEach","seedrandom","startGame","sendStart","getMyUserId","getOppUserId","oppUserId","getMyHand","getOppHand","playerHand","isMyTurnEnabled","getPlayedCards","getRules","methods","handlers","Chat","props","useState","chatMessage","setChatMessage","messages","setMessages","onSendMessage","connRef","current","newMessage","oldm","useEffect","p2p","onChange","target","onKeyUp","onClick","style","whiteSpace","Setup","Play","logic","gameRef","setPlayedCards","myHand","setMyHand","oppHand","setOppHand","myUserId","setMyUserId","setOppUserId","selectedCard","setSelectedCard","myTurn","setMyTurn","setSelectedRules","changeCard","useCallback","currentTarget","toggleRule","updateGameState","Hand","PlayedCards","MyHand","SelectRule","PlayButton","disabled","play","cardstr","secondCharSpades","diff","pass","marginTop","marginBottom","className","Fragment","checked","id","htmlFor","Deck","SelectableDeck","fontSize","GameOver","Rules","Game","setPhase","setRules","Create1","setOffer","setMyOffer","pc","signalingState","createDataChannel","onopen","onmessage","createOffer","d","setLocalDescription","catch","onicecandidate","candidate","localDescription","Create2","joinKey","setJoinKey","offer","answerDesc","RTCSessionDescription","setRemoteDescription","Join1","setAnswer","offerDesc","createAnswer","setMyAnswer","Join2","answer","Welcome","Lobby","myOffer","myAnswer","App","inSetup","setInSetup","useRef","RTCPeerConnection","ondatachannel","channel","oniceconnectionstatechange","iceConnectionState","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.009c3424.chunk.js","sourcesContent":["const RTC_CONFIG = {\n  iceServers: [\n    { urls: [\"stun:stun.l.google.com:19302\", \"stun:stun2.l.google.com:19302\"] },\n  ],\n};\n\n// var haveGum = navigator.mediaDevices\n//   .getUserMedia({ video: true, audio: true })\n//   .catch(console.log);\n\nexport function createConn() {\n  let conn = {\n    pc: new RTCPeerConnection(RTC_CONFIG),\n    dc: null,\n    messageHandlers: {},\n    messageHandlersIndx: \"0\",\n  };\n  conn.pc.ondatachannel = (e) => {\n    conn.dc = e.channel;\n    conn.dc.onopen = () => onOpen(conn);\n    conn.dc.onmessage = (e) => onMessage(conn, e);\n  };\n  conn.pc.oniceconnectionstatechange = (e) =>\n    console.log(conn.pc.iceConnectionState);\n  return conn;\n}\n\nfunction onOpen(conn) {\n  console.log(\"opened chat!!\");\n  console.log(conn.messageHandlers);\n  const data = { type: \"info\", value: \"successfully opened connection!!\" };\n  for (const indx in conn.messageHandlers) {\n    conn.messageHandlers[indx](data);\n  }\n}\nfunction onMessage(conn, e) {\n  console.log(\"received message!\");\n  console.log(conn.messageHandlers);\n  let data = JSON.parse(e.data);\n  console.log(data);\n  for (const indx in conn.messageHandlers) {\n    conn.messageHandlers[indx](data);\n  }\n}\nexport function addMessageHandler(conn, handler) {\n  const indx = conn.messageHandlersIndx;\n  conn.messageHandlers[indx] = handler;\n  conn.messageHandlersIndx = `${parseInt(indx) + 1}`;\n  return indx;\n}\nexport function removeMessageHandler(conn, key) {\n  if (!conn) return;\n  console.log(`removing key ${key} from conn ${conn}`);\n  delete conn.messageHandlers[key];\n}\n\nexport function sendMessage(conn, message) {\n  send(conn, { type: \"message\", message: message });\n}\nexport function sendData(conn, data) {\n  send(conn, { type: \"data\", ...data });\n}\nexport function send(conn, json) {\n  conn.dc.send(JSON.stringify(json));\n}\n\nexport function createOffer(conn, setOffer) {\n  console.log(\"create offer\");\n  console.log(conn.pc.signalingState);\n  conn.dc = conn.pc.createDataChannel(\"chat\");\n\n  conn.dc.onopen = () => onOpen(conn);\n  conn.dc.onmessage = (e) => onMessage(conn, e);\n\n  // haveGum\n  //   .then(() => conn.pc.createOffer())\n  conn.pc\n    .createOffer()\n    .then((d) => conn.pc.setLocalDescription(d))\n    .catch(console.log);\n\n  conn.pc.onicecandidate = (e) => {\n    if (e.candidate) return;\n    setOffer(encodeKey(JSON.stringify(conn.pc.localDescription)));\n  };\n}\n\nfunction encodeKey(json) {\n  return btoa(json).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nfunction decodeKey(key) {\n  let str = key;\n  if (str.length % 4 !== 0) {\n    str += \"===\".slice(0, 4 - (str.length % 4));\n  }\n  str = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  return atob(str);\n}\n\nexport function join(conn, joinKey, setAnswer) {\n  console.log(\"join\");\n  console.log(conn.pc.signalingState);\n  let offerDesc = new RTCSessionDescription(JSON.parse(decodeKey(joinKey)));\n\n  conn.pc\n    .setRemoteDescription(offerDesc)\n    .then(() => conn.pc.createAnswer())\n    .then((d) => conn.pc.setLocalDescription(d))\n    .catch(console.log);\n\n  conn.pc.onicecandidate = (e) => {\n    if (e.candidate) return;\n    setAnswer(encodeKey(JSON.stringify(conn.pc.localDescription)));\n  };\n}\n\nexport function acceptAnswer(conn, joinKey) {\n  console.log(\"join\");\n  console.log(conn.pc.signalingState);\n  var answerDesc = new RTCSessionDescription(JSON.parse(decodeKey(joinKey)));\n  conn.pc.setRemoteDescription(answerDesc).catch(console.log);\n}\n\nexport function numConnections(conn) {\n  // TODO: update this for many players\n  return 1;\n}\n","export default function assert(condition, error_m) {\n  if (condition) return;\n  console.error(\"assertion failed\");\n  console.error(error_m);\n}\n","import assert from \"./assert.js\";\n\nexport function shuffle(array, rng) {\n  var currentIndex = array.length,\n    temporaryValue,\n    randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(rng() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}\n\nexport function unimplemented() {\n  assert(false, \"not implemented yet!!\");\n}\n\nexport async function hash(message) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(message);\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", data);\n  const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array\n  const hashHex = hashArray\n    .map((b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\"); // convert bytes to hex string\n  return hashHex;\n}\n","import * as utils from \"./utils.js\";\n\nexport const RANK = {\n  ACE: \"A\",\n  TWO: \"2\",\n  THREE: \"3\",\n  FOUR: \"4\",\n  FIVE: \"5\",\n  SIX: \"6\",\n  SEVEN: \"7\",\n  EIGHT: \"8\",\n  NINE: \"9\",\n  TEN: \"10\",\n  JACK: \"J\",\n  QUEEN: \"Q\",\n  KING: \"K\",\n};\nexport const RANKS = [\n  RANK.ACE,\n  RANK.TWO,\n  RANK.THREE,\n  RANK.FOUR,\n  RANK.FIVE,\n  RANK.SIX,\n  RANK.SEVEN,\n  RANK.EIGHT,\n  RANK.NINE,\n  RANK.TEN,\n  RANK.JACK,\n  RANK.QUEEN,\n  RANK.KING,\n]; // dont do Object.values because we want to guarantee order\nexport const SUIT = {\n  SPADES: \"spades\",\n  HEARTS: \"hearts\",\n  DIAMONDS: \"diamonds\",\n  CLUBS: \"clubs\",\n};\nexport const SUITS = [SUIT.SPADES, SUIT.HEARTS, SUIT.DIAMONDS, SUIT.CLUBS]; // dont do Object.values because we want to guarantee order\n\nexport const VOID_CARD = \"VOID_CARD\";\n\n//      card is represented by {rank:, suit:} (why no types :(((()))))\n\nexport function orderedDeck(startFromRankIndex) {\n  if (!startFromRankIndex) startFromRankIndex = 0;\n  let deck = [];\n  let suit_index = 0;\n  let index = 0;\n  for (const suit of SUITS) {\n    let rank_index = 0;\n    for (const rank of RANKS) {\n      if (rank_index >= startFromRankIndex) {\n        deck.push({ rank, suit, rank_index, suit_index, index });\n      }\n      rank_index++;\n      index++;\n    }\n    suit_index++;\n  }\n  return deck;\n}\n\nexport function shuffledDeck(rng, startFromRankIndex) {\n  let deck = orderedDeck(startFromRankIndex);\n  return utils.shuffle(deck, rng);\n}\n\n// users: list of IDs for each user who wants a card\n// return: an object {user_id -> array of cards}, as even as possible, union is all cards, disjoint\nexport function dealShuffledCards(users, rng, startFromRankIndex) {\n  let deck = shuffledDeck(rng, startFromRankIndex);\n  let cards = {};\n  let index = 0;\n  for (const user of users) {\n    cards[user] = [];\n  }\n  while (index < deck.length) {\n    for (const user of users) {\n      cards[user].push(deck[index]);\n      index++;\n    }\n  }\n  return cards;\n}\n\nexport function serializeCard(card) {\n  const aceOfSpades = \"ðŸ‚¡\";\n  const firstChar = aceOfSpades.charCodeAt(0);\n  const secondChar = aceOfSpades.charCodeAt(1);\n  return (\n    String.fromCharCode(firstChar) +\n    String.fromCharCode(\n      secondChar +\n        card.rank_index +\n        card.suit_index * 16 +\n        (card.rank === RANK.QUEEN || card.rank === RANK.KING ? 1 : 0)\n    )\n  );\n}\nexport function deserializeCard(cardstr) {\n  const aceOfSpades = \"ðŸ‚¡\";\n  const secondCharSpades = aceOfSpades.charCodeAt(1);\n  const secondChar = cardstr.charCodeAt(1);\n  const diff = secondChar - secondCharSpades;\n  const suit_index = Math.floor(diff / 16);\n  let rank_index = diff % 16;\n  if (rank_index >= 12) {\n    rank_index--;\n  }\n  return {\n    suit: SUITS[suit_index],\n    rank: RANKS[rank_index],\n    suit_index,\n    rank_index,\n    index: suit_index * 13 + rank_index,\n  };\n}\nexport function serializeCardASCII(card) {\n  return card.rank + card.suit.charAt(0).toUpperCase();\n}\n\nexport function serializeDeck(deck) {\n  let deckstr = \"\";\n  for (const card of deck) {\n    deckstr += serializeCard(card);\n  }\n  return deckstr;\n}\n\nexport function sameCard(c1, c2) {\n  if (c1 === VOID_CARD || c2 === VOID_CARD)\n    return c1 === VOID_CARD && c2 === VOID_CARD;\n  return c1.index === c2.index;\n}\n","export const START_FROM_RANK = 12;\n","// rules\n\nimport * as utils from \"./utils.js\";\n\n// rule is a struct containing:\n//  - name: name of the rule\n//  - hash: hash of the compiled source code (same hash as within the snark)\n//  if it is private, also contains:\n//  - source: (the human readable source code written a cool language)\n//  - compiled: (a list of integers which is the compiled version for the snark)\n//  - owner: (the user id of the user owning the rule, or \"everyone\")\n\n// the game will store:\n//  - myRules: a list of my private rules\n//  - allRules: a list of all known public rules\n//  - rulesByOwner: a map {user -> ownedRule}. because if initial rules it is ok for multiple people to know the same rule\n\nexport const EVERYONE = \"everyone\";\n\nexport async function createPrivateRule(name, source, owner) {\n  const rule = {\n    name,\n    source,\n    owner,\n    compiled: compileSource(source),\n    hash: null,\n  };\n  rule.hash = await hashCompiledSource(rule.compiled);\n  return rule;\n}\nexport function publicRule(rule) {\n  // strip out the private parts of this rule, before publishing it to anyone else\n  const publicRule = {\n    name: rule.name,\n    owner: rule.owner,\n    hash: rule.hash,\n  };\n  return publicRule;\n}\n\n// TODO: implement this\nfunction compileSource(source) {\n  console.log(\"compiling source:\");\n  console.log(source);\n  utils.unimplemented();\n\n  return [1, 1, 1, 1, 1, 1 * source.length];\n}\n// TODO: implement this\nasync function hashCompiledSource(compiled) {\n  // should hash in the same way as the snark is doing\n  return await utils.hash(JSON.stringify(compiled));\n}\n\nexport function sameRule(r1, r2) {\n  return r1.hash === r2.hash;\n}\n\n// input:\n//  - card: the card that was played\n//  - playedCards: the cards that have been played so far, not including `card`, 0 is oldest and n-1 is most recently played\n//  - selectedRules: the rules that the player playing `card` selected\n//  - myRules: the private rules (including source code) that we know of and want to check for\n// output:\n//  - a list `provedRules` of length myRules.length, such that provedRules[i] is an object on the form:\n//      {rule: (publicrule object), proof: (snarkproof), penalty: (0 or 1)}\n//    where `rule` is the public rule version of each rule in `myRules`\nexport function determinePenalties(card, playedCards, selectedRules, myRules) {\n  // TODO: implement this\n\n  return myRules.map((rule) => {\n    return {\n      rule: publicRule(rule),\n      proof: \"this is supposed to be a snark proof\",\n      penalty: 0,\n    };\n  });\n}\n","// logic.js is intended to hold all game logic\n\nimport seedrandom from \"seedrandom\";\n\nimport * as p2p from \"./p2p.js\";\nimport * as utils from \"./utils.js\";\nimport * as cards from \"./cards.js\";\nimport * as config from \"./config.js\";\nimport * as rules from \"./rules.js\";\n\nimport assert from \"./assert.js\";\n\n// what's the game state?\n// there's a public part and a private part\n// the public part needs to be agreed upon among all players\n// the private part is\n//\n// PUBLIC:\n// for version 1:\n// 1: the middle deck, which has order\n// 2: each player's hand, which does not have order\n//      invariant: all disjoint, union is all cards\n//\n// for version 2:\n// 3: all the rule hashes\n// 4:\n//\n// PRIVATE:\n// for version 2:\n// 1: your own rules (which is in the form of uhhhh)\n//\n//\n//\n// TODO: later version: add signatures to actually be secure\n\n// WIRE PROTOCOL:\n// always assume broadcast messages!!!!!! this allows us to assume synchronicity which makes everything so much simpler\n// 1. setup:\n//  1.1 everyone: READY hashOfRandomNumber userID (number is a 64-bit integers, user id is randomly generated (later should be public key))\n//  1.2 when everyone you have open connections with say READY: START randomNumber  (userID is sent with every message)\n//  1.3 when received all STARTs: verifies all hashes, xors all numbers, seed rng with this, then just pick cards\n//  1.4 using same seed just choose order\n// 2. play:\n//  2.1 someone: PLAY card userID rules provedRules (same as for playack, need to show you enforce rules consistently even for yourself)\n//  2.2 everyone else: PLAYACK card user userID provedRules (rulehash, snark proof, for each rule you know)\n// 3. abort:\n//  3.1 send ABORT userID to every user, be sad\n\n// ok dont overthink it\n// i think having a hierarchical state thing makes sense\n// this is javascript not rust\n\n// we assume that messages come to people in the order they are sent\n// i.e. we assume that channels are FIFO\n\n// ok so we have:\n// phase = {\"setup\", \"play\", \"gameover\", \"abort\"}\n// each phase has some metadata, which can be public or private\n// the public metadata is always sent over for debugging purposes\n\n// transitions\n// setup:\n//      state = {\"preReady\",\"sentReady\",\"sentStart\"},\n//      players, readyHashes, startNumbers, myRandom\n//\n// play:\n//      nextTurn = index into players\n//      players (order matters),\n//      playedCards (0 bottom, n-1 top),\n//      playerHands (id -> array),\n//      state = {\"waitforplay\", \"waitforack\"}\n//      acksReceived = []\n//      lastPlayedCard\n//      lastPlayedUser\n//\n// gameover: (transitions directly to setup.sentReady)\n//      winner = user_id\n//\n// abort:\n//      (no data)\n\nexport const PHASE = {\n  SETUP: \"SETUP\",\n  PLAY: \"PLAY\",\n  GAMEOVER: \"GAMEOVER\",\n  ABORT: \"ABORT\",\n};\nconst PHASES = Object.values(PHASE);\nconst SETUP_STATE = {\n  PRE_READY: \"PRE_READY\",\n  SENT_READY: \"SENT_READY\",\n  SENT_START: \"SENT_START\",\n};\nconst SETUP_STATES = Object.values(SETUP_STATE);\nconst PLAY_STATE = {\n  WAIT_FOR_PLAY: \"WAIT_FOR_PLAY\",\n  WAIT_FOR_PLAYACK: \"WAIT_FOR_PLAYACK\",\n};\nconst PLAY_STATES = Object.values(PLAY_STATE);\n\nconst METHOD = {\n  READY: \"READY\",\n  START: \"START\",\n  PLAY: \"PLAY\",\n  PLAYACK: \"PLAYACK\",\n  ABORT: \"ABORT\",\n};\nconst METHODS = Object.values(METHOD);\nconst METHOD_HANDLER = {\n  [METHOD.READY]: handleReadyMethod,\n  [METHOD.START]: handleStartMethod,\n  [METHOD.PLAY]: handlePlayMethod,\n  [METHOD.PLAYACK]: handlePlayAckMethod,\n  [METHOD.ABORT]: handleAbortMethod,\n};\nassert(\n  JSON.stringify(METHODS) === JSON.stringify(Object.keys(METHOD_HANDLER)),\n  {\n    methods: METHODS,\n    handlers: METHOD_HANDLER,\n  }\n);\n\nexport function createGame(conn) {\n  // TODO: generate private/public keypair here and let userId be the public key\n  const userId = Math.random().toString(36).substr(2, 9);\n  const game = {\n    conn,\n    listeners: {},\n    listenerIndex: \"0\",\n    userId: userId,\n    phase: null,\n    data: {}, // contains data for every phase\n\n    // rule data\n    myRules: [],\n    allRules: [],\n  };\n  for (const phase of PHASES) {\n    game.data[phase] = {};\n  }\n  initPhase(game, PHASE.SETUP);\n  setUpPublicRules(game);\n  return game;\n}\nfunction setUpPublicRules(game) {\n  // TODO: add more public rules\n  rules\n    .createPrivateRule(\"spades\", \"card.suit == spades\", rules.EVERYONE)\n    .then((rule) => {\n      game.myRules.push(rule);\n      const publicRule = rules.publicRule(rule);\n      game.allRules.push(publicRule);\n      update(game);\n    })\n    .then(() => {\n      return rules.createPrivateRule(\n        \"lastcard\",\n        \"isLastCard()\",\n        rules.EVERYONE\n      );\n    })\n    .then((rule) => {\n      game.myRules.push(rule);\n      const publicRule = rules.publicRule(rule);\n      game.allRules.push(publicRule);\n      update(game);\n    });\n}\nfunction resetPhase(game, phase, args) {\n  assert(PHASES.includes(phase), game);\n  let data = {};\n  if (phase === PHASE.SETUP) {\n    data = {\n      state: SETUP_STATE.PRE_READY,\n      players: [game.userId],\n      readyHashes: {},\n      startNumbers: {},\n      myRandom: null,\n    };\n  } else if (phase === PHASE.PLAY) {\n    // shuffle the player list\n    // note: we need to sort it first before we do it so everyone gets the same list\n\n    data.players = utils.shuffle(\n      [...game.data[PHASE.SETUP].players].sort(),\n      args.rng\n    );\n\n    data.nextTurn = 0;\n\n    data.playedCards = []; // start empty\n\n    // now deal cards\n    data.playerHands = cards.dealShuffledCards(\n      utils.shuffle(data.players, args.rng),\n      args.rng,\n      config.START_FROM_RANK\n    );\n\n    data.state = PLAY_STATE.WAIT_FOR_PLAY;\n\n    data.acksReceived = [];\n    data.lastPlayedCard = null;\n    data.lastPlayedUser = null;\n  }\n  game.data[phase] = data;\n}\nfunction initPhase(game, phase, args) {\n  assert(PHASES.includes(phase), game);\n  resetPhase(game, phase, args);\n  game.phase = phase;\n}\nexport function addListener(game, listener) {\n  const indx = game.listenerIndex;\n  game.listeners[indx] = listener;\n  game.listenerIndex = `${parseInt(indx) + 1}`;\n  return indx;\n}\nexport function removeListener(game, key) {\n  if (!game) return;\n  console.log(`removing key ${key} from game ${game}`);\n  console.log(game);\n  delete game.listeners[key];\n}\n// this function needs to be called every time the game state is updated!!!!!!!!\nfunction update(game) {\n  for (let listener of Object.values(game.listeners)) {\n    listener();\n  }\n}\n\n// m should be on form {data: , method: , ...}\nexport function receive(game, m) {\n  console.log(\"game receiving message!\");\n  console.log(m);\n  if (m.type !== \"data\") {\n    console.log(\"ignoring non-data message\");\n    return;\n  }\n  assert(METHODS.includes(m.method));\n  console.log(METHOD_HANDLER);\n  METHOD_HANDLER[m.method](game, m);\n}\nfunction send(game, m) {\n  // TODO: sign the message\n  m[\"from\"] = game.userId;\n  p2p.sendData(game.conn, m);\n}\n\nfunction handleReadyMethod(game, m) {\n  // should be in setup phase, or gameover phase\n  if (!(game.phase === PHASE.SETUP || game.phase === PHASE.GAMEOVER))\n    return abort(game);\n  const data = game.data[PHASE.SETUP];\n  // should not have sent start already\n  if (\n    !(\n      data.state === SETUP_STATE.PRE_READY ||\n      data.state === SETUP_STATE.SENT_READY\n    )\n  ) {\n    return abort(game);\n  }\n\n  const user = m.from;\n  const hash = m.hash;\n\n  // shouldn't receive twice; should have different IDs\n  if (data.players.includes(user)) return abort(game);\n\n  data.players.push(user);\n  data.readyHashes[user] = hash;\n\n  // if we have received all, send start\n  maybeSendStart(game);\n\n  update(game);\n}\nasync function handleStartMethod(game, m) {\n  // should be in setup phase\n  if (game.phase !== PHASE.SETUP) return abort(game, \"wrong phase\");\n  const data = game.data[PHASE.SETUP];\n  // should have sent ready (not necessarily should have sent start though)\n  if (\n    !(\n      data.state === SETUP_STATE.SENT_READY ||\n      data.state === SETUP_STATE.SENT_START\n    )\n  ) {\n    return abort(game);\n  }\n\n  const user = m.from;\n  const randomNumber = m.randomNumber;\n\n  // shouldn't receive twice\n  if (Object.keys(data.startNumbers).includes(user)) return abort(game);\n\n  // should receive from verified user\n  if (!data.players.includes(user)) return abort(game, `unknown user ${user}`);\n\n  // assert that the hash is ok\n  const randomNumberHash = await utils.hash(`${randomNumber}`);\n  if (data.readyHashes[user] !== randomNumberHash)\n    return abort(\n      game,\n      `incorrect hash ${randomNumberHash} received for random number ${randomNumber} from user ${user}`\n    );\n\n  // add to numbers\n  data.startNumbers[user] = randomNumber;\n\n  // if we have received all, go to the game!!\n  maybeStartGame(game);\n\n  update(game);\n}\nfunction handlePlayMethod(game, m) {\n  if (game.phase !== PHASE.PLAY) return abort(game, \"wrong phase\");\n  const data = game.data[game.phase];\n  if (data.state !== PLAY_STATE.WAIT_FOR_PLAY)\n    return abort(game, \"wrong state\");\n\n  const user = m.from;\n  const card = m.card;\n  const selectedRules = m.rules;\n\n  // make sure it is this user's turn\n  if (user !== data.players[data.nextTurn]) {\n    return abort(game, \"user tried to make move but it's not their turn\");\n  }\n\n  // make sure this user owns this card (or it is voidcard)\n  if (\n    card !== cards.VOID_CARD &&\n    !data.playerHands[user].some((c) => cards.sameCard(c, card))\n  ) {\n    return abort(game, \"user tried to play card not in their hand\");\n  }\n\n  // make sure the card move is legal\n  if (!legalToPlayCard(game, card)) {\n    return abort(game, \"user tried to play illegal card\");\n  }\n\n  // actually do the move\n  actuallyPlayCard(game, user, card);\n\n  sendPlayAck(game, user, card, selectedRules);\n\n  update(game);\n}\nfunction handlePlayAckMethod(game, m) {\n  if (game.phase !== PHASE.PLAY) return abort(game, \"wrong phase\");\n  const data = game.data[game.phase];\n  if (data.state !== PLAY_STATE.WAIT_FOR_PLAYACK)\n    return abort(game, \"wrong state\");\n\n  const user = m.user;\n  const from = m.from;\n  const card = m.card;\n\n  // make sure the right user n right card was acked\n  if (user !== data.lastPlayedUser) {\n    return abort(game, \"tried to ack the wrong user\");\n  }\n  if (!cards.sameCard(card, data.lastPlayedCard)) {\n    return abort(game, \"tried to ack the wrong card\");\n  }\n\n  if (data.acksReceived.includes(from)) {\n    return abort(game, \"already received ack from this user\");\n  }\n\n  // TODO: verify the zk snarks\n\n  data.acksReceived.push(from);\n\n  maybeStopWaitingForAcks(game);\n\n  update(game);\n}\nfunction handleAbortMethod(game, m) {\n  console.log(\"ABORTING :(((( SAD\");\n  utils.unimplemented();\n\n  update(game);\n}\n\nfunction abort(game, reason) {\n  console.error(\"ABORT GAME :((\");\n  console.error(reason);\n  send(game, { method: METHOD.ABORT, reason });\n  game.phase = PHASE.ABORT;\n\n  update(game);\n}\n\nfunction actuallyPlayCard(game, user, card) {\n  const data = game.data[game.phase];\n  data.nextTurn = (data.nextTurn + 1) % data.players.length;\n  data.state = PLAY_STATE.WAIT_FOR_PLAYACK;\n  data.lastPlayedCard = card;\n  data.lastPlayedUser = user;\n  if (card !== cards.VOID_CARD) {\n    data.playedCards.push(card);\n    data.playerHands[user] = data.playerHands[user].filter(\n      (c) => c.index !== card.index\n    );\n  }\n  update(game);\n}\n\nfunction legalToPlayCard(game, card) {\n  const data = game.data[game.phase];\n  // always ok to pass\n  if (card === cards.VOID_CARD) return true;\n  // first move always legal\n  if (data.playedCards.length === 0) return true;\n  // either suit or rank must be the same\n  const lastCard = data.playedCards[data.playedCards.length - 1];\n  return lastCard.suit === card.suit || lastCard.rank === card.rank;\n}\n\nexport function playCard(game, card, selectedRules) {\n  assert(game.phase === PHASE.PLAY && isMyTurn(game), game);\n  const data = game.data[game.phase];\n  assert(data.state === PLAY_STATE.WAIT_FOR_PLAY, game);\n  assert(\n    card === cards.VOID_CARD ||\n      data.playerHands[game.userId].some((c) => cards.sameCard(c, card)),\n    game\n  );\n  assert(\n    selectedRules.every(\n      (rule) => game.allRules.filter((x) => rules.sameRule(x, rule)) > 0\n    )\n  );\n  console.log(`play card!`);\n  console.log(card);\n  console.log(selectedRules);\n\n  assert(legalToPlayCard(game, card), game);\n\n  // we do this for ourselves. we need to run the snarks\n  // to prove to others that we enforce our own rules correctly even on ourselves\n  const provedRules = rules.determinePenalties(\n    card,\n    data.playedCards.slice(0, data.playedCards.length - 1),\n    selectedRules,\n    game.myRules\n  );\n  // TODO: record how many penalties were received (probably 0 lol u should know your own rules)\n\n  send(game, { method: METHOD.PLAY, card, rules: selectedRules, provedRules });\n\n  actuallyPlayCard(game, game.userId, card);\n  update(game);\n}\n\nexport function restartGame(game) {\n  game.phase = PHASE.SETUP;\n\n  sendReady(game);\n}\n\nexport async function sendReady(game) {\n  assert(game.phase === PHASE.SETUP, game);\n  const data = game.data[PHASE.SETUP];\n  assert(data.state === SETUP_STATE.PRE_READY, game);\n  // generate a random number\n  data.myRandom = Math.floor(Math.random() * 2 ** 64);\n  // hash the random number\n  const hash_r = await utils.hash(`${data.myRandom}`);\n  console.log(hash_r);\n  data.readyHashes[game.userId] = hash_r;\n  send(game, { method: METHOD.READY, hash: hash_r });\n  data.state = SETUP_STATE.SENT_READY;\n  maybeSendStart(game);\n\n  update(game);\n}\n\nfunction checkIfWon(game) {\n  assert(game.phase === PHASE.PLAY, game);\n  const data = game.data[game.phase];\n  assert(data.state === PLAY_STATE.WAIT_FOR_PLAY, game);\n\n  for (const user of data.players) {\n    if (data.playerHands[user].length === 0) {\n      // someone won!!!!\n      // assert only one player won\n      assert(\n        Object.values(data.playerHands).filter((l) => l.length === 0).length ===\n          1\n      );\n\n      game.phase = PHASE.GAMEOVER;\n      game.data[PHASE.GAMEOVER].winner = user;\n    }\n  }\n}\n\nfunction maybeStopWaitingForAcks(game) {\n  const data = game.data[game.phase];\n  // everyone except the player needs to ack the card\n  if (data.acksReceived.length === data.players.length - 1) {\n    data.state = PLAY_STATE.WAIT_FOR_PLAY;\n    data.acksReceived = [];\n    data.lastPlayedCard = null;\n    data.lastPlayedUser = null;\n\n    // check if someone won\n    checkIfWon(game);\n\n    update(game);\n  }\n}\n\nfunction sendPlayAck(game, user, card, selectedRules) {\n  assert(game.phase === PHASE.PLAY, game);\n  const data = game.data[game.phase];\n  assert(data.state === PLAY_STATE.WAIT_FOR_PLAYACK, game);\n\n  const provedRules = rules.determinePenalties(\n    card,\n    data.playedCards.slice(0, data.playedCards.length - 1),\n    selectedRules,\n    game.myRules\n  );\n  // TODO: record how many penalties were received\n\n  send(game, { method: METHOD.PLAYACK, card, user, provedRules });\n\n  assert(!data.acksReceived.includes(game.userId), game);\n  data.acksReceived.push(game.userId);\n\n  maybeStopWaitingForAcks(game);\n\n  update(game);\n}\n\nfunction maybeStartGame(game) {\n  const data = game.data[game.phase];\n  if (data.players.length === Object.keys(data.startNumbers).length) {\n    startGame(game);\n  }\n}\nfunction startGame(game) {\n  assert(game.phase === PHASE.SETUP);\n  const data = game.data[game.phase];\n  assert(data.state === SETUP_STATE.SENT_START, game);\n\n  // xor all the random numbers (which means that as long as at least 1 person honest, it is random)\n  let finalRandomNumber = 0;\n  Object.values(data.startNumbers).forEach((randomNumber) => {\n    finalRandomNumber ^= randomNumber;\n  });\n\n  console.log(`final randomness: ${finalRandomNumber}`);\n  // use this random number as the seed of an rng\n  let rng = seedrandom(`${finalRandomNumber}`);\n\n  // now we can transition to the game phase\n  // delete the old game object properties\n  initPhase(game, PHASE.PLAY, { rng });\n  resetPhase(game, PHASE.SETUP);\n\n  console.log(\"STARTING GAME!!!! exciting :)))\");\n  console.log(game);\n\n  update(game);\n}\n\nfunction maybeSendStart(game) {\n  const data = game.data[PHASE.SETUP];\n  if (\n    p2p.numConnections(game.conn) ===\n    Object.keys(data.readyHashes).length - 1\n  ) {\n    assert(data.players.length === Object.keys(data.readyHashes).length, game);\n    sendStart(game);\n  }\n}\nfunction sendStart(game) {\n  assert(game.phase === PHASE.SETUP, game);\n  const data = game.data[game.phase];\n  assert(data.state === SETUP_STATE.SENT_READY, game);\n\n  send(game, { method: METHOD.START, randomNumber: data.myRandom });\n\n  data.startNumbers[game.userId] = data.myRandom;\n  data.state = SETUP_STATE.SENT_START;\n\n  maybeStartGame(game);\n\n  update(game);\n}\n\n// convenience for 2 players\n// TODO: update this for more players\n\nexport function getMyUserId(game) {\n  return game.userId;\n}\nexport function getOppUserId(game) {\n  const data = game.data[PHASE.PLAY];\n  const oppUserId = data.players.filter((x) => x !== getMyUserId(game))[0];\n  console.log(`opp user id: ${oppUserId}`);\n  return oppUserId;\n}\nexport function getMyHand(game) {\n  const data = game.data[PHASE.PLAY];\n  return data.playerHands[getMyUserId(game)];\n}\nexport function getOppHand(game) {\n  const data = game.data[PHASE.PLAY];\n  const playerHand = data.playerHands[getOppUserId(game)];\n  console.log(\"player hand!\");\n  console.log(JSON.stringify(playerHand));\n  return playerHand;\n}\nfunction isMyTurn(game) {\n  const data = game.data[PHASE.PLAY];\n  return getMyUserId(game) === data.players[data.nextTurn];\n}\nexport function isMyTurnEnabled(game) {\n  const data = game.data[PHASE.PLAY];\n  return isMyTurn(game) && data.state === PLAY_STATE.WAIT_FOR_PLAY;\n}\n\nexport function getPlayedCards(game) {\n  const data = game.data[PHASE.PLAY];\n  return data.playedCards;\n}\n\nexport function getWinner(game) {\n  const data = game.data[PHASE.GAMEOVER];\n  return data.winner;\n}\n\nexport function getRules(game) {\n  return game.allRules;\n}\n","import React from \"react\";\nimport { useRef, useEffect, useState } from \"react\";\nimport * as p2p from \"./p2p.js\";\n\nexport function Chat(props) {\n  const [chatMessage, setChatMessage] = useState(\"\");\n  const [messages, setMessages] = useState(\"\");\n\n  function onSendMessage() {\n    p2p.sendMessage(props.connRef.current, chatMessage);\n    newMessage(chatMessage);\n    setChatMessage(\"\");\n  }\n\n  function newMessage(m) {\n    setMessages((oldm) => {\n      if (oldm === \"\") return m;\n      return m + \"\\n\" + oldm;\n    });\n  }\n\n  useEffect(() => {\n    const indx = p2p.addMessageHandler(props.connRef.current, (m) => {\n      if (m.type === \"message\") return newMessage(m.message);\n      newMessage(JSON.stringify(m));\n    });\n    return () => {\n      console.log(`cleaning up chat!!! index ${indx}`);\n      p2p.removeMessageHandler(props.connRef.current, indx);\n    };\n  }, [props.connRef]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={chatMessage}\n        onChange={(e) => setChatMessage(e.target.value)}\n        onKeyUp={(e) => (e.key === \"Enter\" ? onSendMessage() : 0)}\n      ></input>\n      <button onClick={onSendMessage}>Send message</button>\n      <p style={{ whiteSpace: \"pre-line\" }}>{messages}</p>\n    </div>\n  );\n}\n","import \"./Game.css\";\nimport React from \"react\";\nimport { useCallback, useRef, useEffect, useState } from \"react\";\nimport * as p2p from \"./p2p.js\";\nimport * as logic from \"./logic.js\";\nimport * as cards from \"./cards.js\";\nimport * as rules from \"./rules.js\";\n\nimport { Chat } from \"./Chat.js\";\n\nfunction Setup() {\n  return <div>Waiting for everyone else to press start...</div>;\n}\n\nfunction Play(props) {\n  const [playedCards, setPlayedCards] = useState(\n    logic.getPlayedCards(props.gameRef.current)\n  );\n  const [myHand, setMyHand] = useState(logic.getMyHand(props.gameRef.current));\n  const [oppHand, setOppHand] = useState(\n    logic.getOppHand(props.gameRef.current)\n  );\n  const [myUserId, setMyUserId] = useState(\n    logic.getMyUserId(props.gameRef.current)\n  );\n  const [oppUserId, setOppUserId] = useState(\n    logic.getOppUserId(props.gameRef.current)\n  );\n  const [selectedCard, setSelectedCard] = useState(null);\n  const [myTurn, setMyTurn] = useState(\n    logic.isMyTurnEnabled(props.gameRef.current)\n  );\n  const [selectedRules, setSelectedRules] = useState([]);\n\n  const changeCard = useCallback((e) => {\n    setSelectedCard(e.currentTarget.value);\n  }, []);\n\n  const toggleRule = useCallback(\n    (e) => {\n      const rule = JSON.parse(e.currentTarget.value);\n      console.log(`toggling rule ${rule.name}`);\n      if (selectedRules.filter((x) => rules.sameRule(x, rule)).length > 0) {\n        setSelectedRules(selectedRules.filter((x) => !rules.sameRule(x, rule)));\n      } else {\n        setSelectedRules([rule, ...selectedRules]);\n      }\n    },\n    [selectedRules]\n  );\n\n  const updateGameState = useCallback(() => {\n    setPlayedCards(logic.getPlayedCards(props.gameRef.current));\n    setMyHand(logic.getMyHand(props.gameRef.current));\n    setOppHand(logic.getOppHand(props.gameRef.current));\n    setMyUserId(logic.getMyUserId(props.gameRef.current));\n    setOppUserId(logic.getOppUserId(props.gameRef.current));\n    setMyTurn(logic.isMyTurnEnabled(props.gameRef.current));\n  }, [props.gameRef]);\n\n  useEffect(() => {\n    const indx = logic.addListener(props.gameRef.current, updateGameState);\n    return () => {\n      logic.removeListener(props.gameRef.current, indx);\n    };\n  }, [props.gameRef, updateGameState]);\n\n  return (\n    <div>\n      <Hand cards={oppHand} user={oppUserId} />\n      <PlayedCards cards={playedCards} />\n      <MyHand\n        cards={myHand}\n        user={myUserId}\n        changeCard={changeCard}\n        selectedCard={selectedCard}\n      />\n      <SelectRule\n        rules={props.rules}\n        selectedRules={selectedRules}\n        toggleRule={toggleRule}\n      />\n      <PlayButton\n        disabled={!myTurn || props.disabled}\n        play={() => {\n          logic.playCard(\n            props.gameRef.current,\n            cards.deserializeCard(selectedCard),\n            selectedRules\n          );\n          setSelectedRules([]);\n        }}\n        pass={() => {\n          logic.playCard(props.gameRef.current, cards.VOID_CARD, selectedRules);\n          setSelectedRules([]);\n        }}\n      />\n    </div>\n  );\n}\n\nfunction SelectRule(props) {\n  return (\n    <div style={{ marginTop: \"5px\", marginBottom: \"7px\" }}>\n      rules:\n      <div className=\"SelectRule\">\n        {props.rules.map((rule, index) => {\n          return (\n            <React.Fragment key={`rulesfragment${index}`}>\n              <input\n                type=\"checkbox\"\n                name=\"rules\"\n                value={JSON.stringify(rule)}\n                checked={\n                  props.selectedRules.filter((x) => rules.sameRule(x, rule))\n                    .length > 0\n                }\n                onChange={props.toggleRule}\n                id={rule.hash}\n                key={`rulesradio${index}`}\n              />\n              <label htmlFor={rule.hash} key={`ruleslabel${index}`}>\n                {rule.name}\n              </label>\n            </React.Fragment>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n\nfunction PlayButton(props) {\n  return (\n    <div>\n      <button onClick={props.play} disabled={props.disabled}>\n        Play!\n      </button>\n      <button onClick={props.pass} disabled={props.disabled}>\n        Pass\n      </button>\n    </div>\n  );\n}\n\nfunction PlayedCards(props) {\n  return (\n    <div>\n      played cards: <Deck cards={props.cards} />\n    </div>\n  );\n}\n\nfunction Hand(props) {\n  return (\n    <div>\n      {props.user}'s cards:\n      <Deck cards={props.cards} />\n    </div>\n  );\n}\nfunction MyHand(props) {\n  return (\n    <div>\n      my cards:\n      <SelectableDeck\n        cards={props.cards}\n        changeCard={props.changeCard}\n        selectedCard={props.selectedCard}\n      />\n    </div>\n  );\n}\nfunction Deck(props) {\n  if (props.cards.length === 0) {\n    return <div>(none)</div>;\n  }\n  return (\n    <div style={{ fontSize: \"3em\" }}>{cards.serializeDeck(props.cards)}</div>\n  );\n}\nfunction SelectableDeck(props) {\n  if (props.cards.length === 0) {\n    return <div>(none)</div>;\n  }\n  return (\n    <div style={{ fontSize: \"3em\" }} className=\"SelectableDeck\">\n      {props.cards.map((card, index) => {\n        return (\n          <React.Fragment key={`mycardsfragment${index}`}>\n            <input\n              type=\"radio\"\n              name=\"mycards\"\n              value={cards.serializeCard(card)}\n              checked={props.selectedCard === cards.serializeCard(card)}\n              onChange={props.changeCard}\n              id={cards.serializeCardASCII(card)}\n              key={`mycardsradio${index}`}\n            />\n            <label\n              htmlFor={cards.serializeCardASCII(card)}\n              key={`mycardslabel${index}`}\n            >\n              {cards.serializeCard(card)}\n            </label>\n          </React.Fragment>\n        );\n      })}\n    </div>\n  );\n}\n\nfunction GameOver(props) {\n  return (\n    <div>\n      <div style={{ fontSize: \"2em\" }}>\n        Game is over!!!! {props.winner} won!\n      </div>\n      <button onClick={() => logic.restartGame(props.gameRef.current)}>\n        Play again!\n      </button>\n    </div>\n  );\n}\n\nfunction Rules(props) {\n  return (\n    <div>\n      Rules:\n      <ul>\n        {props.rules.map((rule) => {\n          return <li>{JSON.stringify(rule)}</li>;\n        })}\n      </ul>\n    </div>\n  );\n}\n\nexport function Game(props) {\n  const [phase, setPhase] = useState(props.gameRef.current.phase);\n  const [myUserId, setMyUserId] = useState(\n    logic.getMyUserId(props.gameRef.current)\n  );\n  const [rules, setRules] = useState(logic.getRules(props.gameRef.current));\n\n  const updateGameState = useCallback(() => {\n    setPhase(props.gameRef.current.phase);\n    setMyUserId(logic.getMyUserId(props.gameRef.current));\n    setRules(logic.getRules(props.gameRef.current));\n  }, [props.gameRef]);\n\n  useEffect(() => {\n    const indx = logic.addListener(props.gameRef.current, updateGameState);\n    return () => {\n      logic.removeListener(props.gameRef.current, indx);\n    };\n  }, [props.gameRef, updateGameState]);\n\n  return (\n    <div>\n      welcome to the game, {myUserId}!\n      <hr />\n      {phase === logic.PHASE.GAMEOVER && (\n        <React.Fragment>\n          <GameOver\n            gameRef={props.gameRef}\n            winner={logic.getWinner(props.gameRef.current)}\n          />\n          <hr />\n        </React.Fragment>\n      )}\n      {phase === logic.PHASE.SETUP && (\n        <React.Fragment>\n          <Setup />\n          <hr />\n        </React.Fragment>\n      )}\n      <Rules rules={rules} />\n      <hr />\n      {(phase === logic.PHASE.PLAY || phase === logic.PHASE.GAMEOVER) && (\n        <React.Fragment>\n          <Play\n            gameRef={props.gameRef}\n            disabled={phase === logic.PHASE.GAMEOVER}\n            rules={rules}\n          />\n          <hr />\n        </React.Fragment>\n      )}\n      <Chat connRef={props.connRef} />\n    </div>\n  );\n}\n","import \"./App.css\";\nimport React from \"react\";\nimport { useCallback, useRef, useEffect, useState } from \"react\";\nimport * as p2p from \"./p2p.js\";\nimport * as logic from \"./logic.js\";\n\nimport { Game } from \"./Game.js\";\nimport { Chat } from \"./Chat.js\";\n\nfunction Create1(props) {\n  return (\n    <div>\n      <button\n        onClick={() => p2p.createOffer(props.connRef.current, props.setMyOffer)}\n      >\n        Create game\n      </button>\n    </div>\n  );\n}\n\nfunction Create2(props) {\n  const [joinKey, setJoinKey] = useState(\"\");\n  return (\n    <div>\n      send this message to your friends: <code>{props.offer}</code>\n      <br />\n      input their answer:\n      <input\n        type=\"text\"\n        value={joinKey}\n        onChange={(e) => setJoinKey(e.target.value)}\n      ></input>\n      <button onClick={() => p2p.acceptAnswer(props.connRef.current, joinKey)}>\n        Add player\n      </button>\n    </div>\n  );\n}\n\nfunction Join1(props) {\n  const [joinKey, setJoinKey] = useState(\"\");\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={joinKey}\n        onChange={(e) => setJoinKey(e.target.value)}\n      ></input>\n      <button\n        onClick={() =>\n          p2p.join(props.connRef.current, joinKey, props.setMyAnswer)\n        }\n      >\n        Join\n      </button>\n    </div>\n  );\n}\n\nfunction Join2(props) {\n  return (\n    <div>\n      send this message to your friends: <code>{props.answer}</code>\n      <br />\n    </div>\n  );\n}\n\nfunction Welcome(props) {\n  console.log(props.connRef);\n  return (\n    <div>\n      <Create1 connRef={props.connRef} setMyOffer={props.setMyOffer} />\n      <br />\n      <Join1 connRef={props.connRef} setMyAnswer={props.setMyAnswer} />\n      <br />\n    </div>\n  );\n}\n\nfunction Lobby(props) {\n  return (\n    <div>\n      {props.offer ? (\n        <Create2 connRef={props.connRef} offer={props.offer} />\n      ) : (\n        <Join2 connRef={props.connRef} answer={props.answer} />\n      )}\n      <hr />\n      Participants list: idk\n      <br />\n      <hr />\n      <button onClick={props.startGame}>Start game!</button>\n      <hr />\n      <Chat connRef={props.connRef} />\n    </div>\n  );\n}\n\nfunction Setup(props) {\n  const [myOffer, setMyOffer] = useState(null);\n  const [myAnswer, setMyAnswer] = useState(null);\n\n  if (myOffer || myAnswer) {\n    return (\n      <Lobby\n        connRef={props.connRef}\n        offer={myOffer}\n        answer={myAnswer}\n        startGame={props.startGame}\n      />\n    );\n  } else {\n    return (\n      <React.Fragment>\n        <Welcome\n          connRef={props.connRef}\n          setMyOffer={setMyOffer}\n          setMyAnswer={setMyAnswer}\n        />\n      </React.Fragment>\n    );\n  }\n}\n\nfunction App() {\n  const [inSetup, setInSetup] = useState(true);\n  const connRef = useRef();\n  const gameRef = useRef();\n\n  const startGame = useCallback(() => {\n    setInSetup(false);\n    logic.sendReady(gameRef.current);\n  }, [gameRef]);\n\n  useEffect(() => {\n    connRef.current = p2p.createConn();\n    gameRef.current = logic.createGame(connRef.current);\n  }, []);\n\n  useEffect(() => {\n    const indx = p2p.addMessageHandler(connRef.current, (m) =>\n      logic.receive(gameRef.current, m)\n    );\n    return () => {\n      p2p.removeMessageHandler(connRef.current, indx);\n    };\n  }, [connRef, gameRef]);\n\n  return (\n    <div className=\"App\">\n      {inSetup && <Setup connRef={connRef} startGame={startGame} />}\n      {!inSetup && <Game connRef={connRef} gameRef={gameRef} />}\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}